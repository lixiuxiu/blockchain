# fabric架构图

![未命名文件-2](https://ws2.sinaimg.cn/large/006tNbRwgy1fwcc4sian2j31160ta0wp.jpg)



MSP实现成员管理，是fabric中的一个组件，每个节点都有MSP颁发的一个证书用于实现签名和身份认证，证书hash后会导出一个PKI-ID值，所有节点信息都是以PKI-ID标识的。

如果所有节点是双向TLS部署的，那TLS连接双方都有一个有效的TLS证书，在点对点第一次连接时会用到。



节点启动后会发送AliveMessage消息，接收到消息的节点会更新本地的存活节点列表。每个节点还周期性的检查本地存活节点列表



节点数据基于反熵的状态同步：每个节点定期（10s）检查本地账本的区块序列号，若发现本地序列号小于他人的，那就广播一个消息来请求缺失的区块。



kafaka只提供崩溃容错，不提供拜占庭容错，不能防止恶意节点攻击。

记账节点和排序节点都会存储账本数据(区块文件)，但是排序节点不存储状态数据和历史数据

每个链的账本存储在不同的目录下，而状态数据是以chaincodeID相关，进行逻辑分离



链码容器启动后，会和启动它的背书节点建立gRPC连接，应用程序或者命令行通过gPRC连接给背书节点发送请求，背书节点校验通过后将请求通过建立的gPRC连接发送给链码， 链码只接收启动它的背书节点的指令，链码应该安装到需要运行链码的背书节点上，具体安装到哪些节点，可以根据背书策略来选择。每次链码调用的时候生成一个交易模拟器TxSimulator

### 步骤2

客户端sdk 发送提案给peer节点，peer处理后会提交交易提案给背书节点

客户端sdk根据背书策略选择背书节点，给这些节点发送需要执行的交易提案，背书节点调用链码执行这些交易提案

交易背书和交易验证由内置的系统链码来实现的，也可以自己编写背书和验证的功能逻辑实现成链码，在提交交易提案时指定新的交易背书和交易验证链码。

排序服务接口会实现基于BFT协议的算法（1.0），当然我们可以自定义一个排序服务，他的实现是可插拔的。

每个排序节点启动的时候会需要一个创世区块，通过configtxgen工具生成的，系统链是通过创世区块配置的，他只存在于排序服务中，包含区块链配置信息，组织信息，msp以及一些策略信息。

sdk提交通道配置交易向排序服务发起创建通道请求，通道配置交易由configtxgen生成。排序服务接到请求，会线检查是否是配置交易，然后添加到系统链的交易消息队列中处理

### 步骤3

基于SDK开发的应用程序或者命令行程序通过gRPC通道给排序服务提交背书节点模拟执行后的交易。排序服务根据交易的请求头来确定通道信息

### 步骤4 

基于Gossip的协议p2p数据分发。Gossip模块负责连接排序服务和peer节点上，实现单源节点到所有节点到高效数据分发。每个通过Gossip协议转发给其他节点的消息都附上该节点的信息：PKI-ID，节点签名，并能通过节点的证书进行验证，配置文件中指定启动连接节点，节点上的Gossip模块都会绑定gRPC端口

**主节点**是通过组织内的节点选举产生的或者是配置文件指定的，选举产生后，如果当前主节点掉线，剩余节点名字靠前的节点声明为主节点，等待有效时间结束后，会产生下一轮的主节点选举的过程。

它通过一个接口函数连接到排序服务。它的作用就是连接外部的排序服务和其他组织的主节点，并把批量区块分发给组织内的其他节点。

在生产环境中，对于排序服务节点和Kafka节点之间的加密传输，需要在传输的两端进行设置，使用TLS传输。两端生产TLS证书。



